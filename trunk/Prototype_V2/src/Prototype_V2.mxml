<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="1024" minHeight="600">
	<fx:Script>
		<![CDATA[
			import mx.charts.chartClasses.StackedSeries;
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.core.UIComponent;
			import mx.graphics.codec.PNGEncoder;
			import mx.managers.CursorManager;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;

			[Bindable]
			public var taille:int;
			public var point:Point = new Point();
			public var tailleRef:int = -1;
			public var prevBitmap:Bitmap = null;
			public var drawBitmap:Bitmap = null;
			public var centerx:int = 0;
			public var centery:int = 0;
			public var prevCenterx:int = -1;
			public var prevCentery:int = -1;
			public var w:int = 340;
			public var h:int = 3*w/4;
			public var f:int = 20;
			public var timer:Timer = new Timer(1000/f, 0);
			public var tab:BitmapData = new BitmapData(w, h, true);

			private function loadCamera () : void
			{
				var camera:Camera = Camera.getCamera();
				//Alert.show(Camera.names.toString());
				if (camera)
				{
					var i:int = 0;
					var j:int = 0;
					var rgb:int = 0;
					camera.setMode(w, h, f, true);
					videoCamera.attachCamera(camera);
					timer.addEventListener("timer", takeSnapshot);
					timer.start();
				}
				else
				{
					Alert.show("pas de webcam.");
				}
				drawBitmap = new Bitmap(new BitmapData(w, h, true));
				componentMoved.addChild(drawBitmap);
			}
			private function takeSnapshot(e:String) : void
			{
				//var snapshotHolder:UIComponent = new UIComponent();
				var snapshotColor:BitmapData = new BitmapData(
					videoCamera.width, 
					videoCamera.height, 
					true);
				var snapshotMove:BitmapData = new BitmapData(
					videoCamera.width, 
					videoCamera.height, 
					true);
				var snapshot:BitmapData = new BitmapData(
					videoCamera.width, 
					videoCamera.height, 
					true);
				
				//var pnWidth:int = pnSnapShot.width;
				//var pnHeight:int = pnSnapShot.height;
				
				//snapshotHolder.addChild(snapshotBitmap);
				//pnSnapShot.removeAllChildren();
				//pnSnapShot.width = pnWidth;
				//pnSnapShot.height = pnHeight;
				
				snapshot.draw(videoCamera);
				//REVERSE IMAGE
				var i:int = 0;
				var j:int = 0;
				var rgb:int = 0;
				for (i = 0; i < w / 2; i++)
				{
					for (j = 0; j < h; j++)
					{
						rgb = snapshot.getPixel(i, j);
						snapshot.setPixel(i, j, snapshot.getPixel(w - i, j));
						snapshot.setPixel(w - i, j, rgb);
					}
				}
				//END OF REVERSE IMAGE
				
				snapshotColor.draw(snapshot);
				snapshotMove.draw(snapshot);
				processImage(snapshotColor);
				//pnSnapShot.addChild(snapshotHolder);

				//var snapshotBitmap2:Bitmap = new Bitmap(snapshotOrig);
				if (prevBitmap)
				{
					//var snapshotBitmapData:BitmapData = new BitmapData(w, h, true);
					/*var i:int = 0;
					var j:int = 0;
					for (i = 0; i < w; i++)
					{
						for (j = 0; j < h; j++)
						{
							var RGB:int = snapshotMove.getPixel(i,j); 
							var RGB2:int = prevBitmap.bitmapData.getPixel(i,j); 
							RGB = RGB + 16777216;
							RGB2 = RGB2 + 16777216; 
							var a:int = getR(RGB);
							var b:int = getG(RGB);
							var c:int = getB(RGB);
							var d:int = getR(RGB2);
							var ee:int = getG(RGB2);
							var f:int = getB(RGB2);
							
							if (a-c + b-ee + c-f < 100)
							{
								snapshotMove.setPixel(i,j, 0);
							}
							else
							{
								snapshotMove.setPixel(i,j,255*256*256);
							}
								
						}
					}*/
					//snapshotMove = snapshotMove.compare(prevBitmap.bitmapData) as BitmapData;
					// CODE INTERNET
					//var rect:Rectangle = new Rectangle(0, 0, w, h);
					//var pt:Point = new Point(0, 0);
					
					//snapshotMove.draw(prevBitmap.bitmapData, new Matrix(), new ColorTransform(), 'subtract');
					//snapshotMove.threshold(snapshotMove, rect, pt, '>', 0xff111111, 0xffffffff);
					
					//END OF CODE INTERNET
					//componentMoved.addChild(new Bitmap(snapshotMove));
				}
				prevBitmap = new Bitmap(snapshot);
				var snapshotBitmapColor:Bitmap = new Bitmap(snapshotColor);
				component.addChild(snapshotBitmapColor);
				//savePicture(snapshot);
			}
			private function clickButton() : void
			{
				tailleRef = taille;
			}
			private function eraseScreen() : void
			{
				componentMoved.removeChild(drawBitmap);
				drawBitmap = new Bitmap(new BitmapData(w, h, true));
				componentMoved.addChild(drawBitmap);
			}
			private function getR(RGB:int) :int {
				return ((RGB / 256) / 256) % 256;
			}
			private function getG(RGB:int) : int
			{
				return (RGB / 256) % 256;
				//return RGB & 0x10000000;
			}
			private function getB(RGB:int) : int {
				return (RGB) % 256;
			}
			private function drawRectangle(img:BitmapData, x:int, y:int, xx:int, yy:int, color:int) : void {
				var i:int = 0;
				var j:int = 0;
				for(i = x; i <= xx; i++)
				{
					img.setPixel(i, y, color);
					img.setPixel(i, yy, color);
				}
				for (j = y; j < yy; j++)
				{
					img.setPixel(x, j, color);
					img.setPixel(xx, j, color);
				}
			}			
			private function drawLines(img:BitmapData, x:int, y:int, color:int) : void
			{
				var i:int = 0;
				for (i = 0; i < img.width; i++)
					img.setPixel(i, y, color);
				for (i = 0; i < img.height; i++)
					img.setPixel(x, i, color);
			}
			private function drawLine(img:BitmapData, x:int, y:int, xx:int, yy:int, color:int) : void
			{
				var i:int = 100;
				while (i >= 0)
				{
					img.setPixel(x + i * (xx - x)/100, y + i * (yy - y)/100, color);
					i--;
				}
			}
			private function checkPoint(img:BitmapData, x:int, y:int) : Boolean
			{
				if (x >= 0 && y >= 0 && x < w && y < h)
				{
					if (tab.getPixel(x, y) != 0)
						return false;
					var RGB:int = img.getPixel(x, y);
					RGB = RGB + 16777216;
					var R:int = getR(RGB);
					var G:int = getG(RGB);
					var B:int = getB(RGB);
					return (r_min.value <= R && R <= r_max.value && g_min.value <= G && G <= g_max.value && b_min.value <= B && B <= b_max.value);
				}
				return false;
			}
			private function interpolGroup(img:BitmapData, x:int, y:int, n:int) : void
			{
				var varI:int;
				var varJ:int;
				var f:ArrayCollection = new ArrayCollection();
				var r:int = 2; // interpolation a deux pixels
				var size:int = 0;
				var p:Point = new Point();
				var arround:Point;
				var center:Point = new Point();
				var color:int = 0;
				switch (n)
				{
					case 0 : color = 0; break;
					case 1 : color = 255; break;
					case 2 : color = 255*256; break;
					case 3 : color = 255*256*256; break;
					case 4 : color = 255 + 255*256; break;
					case 5 : color = 255 + 255*256*256; break;
				}
				center.x = 0;
				center.y = 0;
				p.x = x;
				p.y = y;
				f.addItem(p);
				while (f.length > 0)
				{
					p = f.getItemAt(0) as Point;
					f.removeItemAt(0);
					if (tab.getPixel(p.x, p.y) != 0)
						continue;
					
					tab.setPixel(p.x, p.y, n);
					img.setPixel(p.x, p.y, color);
					size++;
					center.x += p.x;
					center.y += p.y;
					for (varI = -r; varI < r; varI++)
					{
						for (varJ = -r; varJ < r; varJ++)
						{
							if (varI == 0 && varJ == 0)
								continue;
							if (checkPoint(img, p.x + varI, p.y + varJ))
							{
								arround = new Point();
								arround.x = p.x + varI;
								arround.y = p.y + varJ;
								f.addItem(arround);
							}
						}
					}
				}
				//le groupe numero 'n' contient 'taille' pixels.
				if (size > taille)// si on a trouver plus grand
				{
					taille = size;
					point.x = center.x / size;
					point.y = center.y / size;
				}
			}
			private function findGroups (img:BitmapData) : void
			{
				var i:int;
				var j:int;
				var n:int = 1;
				taille = 0;
				point.x = 0;
				point.y = 0;
				for (i = 0; i < w; i++)
				{
					for (j = 0; j < h; j++)
					{
						tab.setPixel(i, j, 0);
					}
				}
				for (i = 0; i < w; i++)
				{
					for (j = 0; j < h; j++)
					{
						if (checkPoint(img, i, j))
						{
							interpolGroup(img, i, j , n);
							n++;
						}
					}
				}
			}
			private function processImage(img:BitmapData) : void
			{
				//searchColor(img, r_min.value, r_max.value, g_min.value, g_max.value, b_min.value, b_max.value, 255*256*256);
				//searchColorAndBinaries(img, r_min.value, r_max.value, g_min.value, g_max.value, b_min.value, b_max.value, 255*256*256);
				prevCenterx = point.x;
				prevCentery = point.y;
				findGroups(img);
				if ((tailleRef != -1) && (taille > 1.3*tailleRef))
				{
					if ((prevCenterx > 0) && (point.x > 0))
					{
						drawLine(drawBitmap.bitmapData, prevCenterx, prevCentery, point.x, point.y, 255*256*256);
					}
					drawLines(img, point.x, point.y, 255*256*256);
					drawBitmap.bitmapData.setPixel(point.x, point.y, 255*256*256); 
				}
				else
				{
					drawLines(img, point.x, point.y, 0);
					prevCenterx = -1;
					prevCentery = -1;
				}
			}
			private function searchColor(img:BitmapData, R_min:int, R_max:int, G_min:int, G_max:int, B_min:int, B_max:int, color:int) : void
			{
				var x:int = -1;
				var y:int = -1;
				var xx:int = -1;
				var yy:int = -1;
				var i:int;
				var j:int;
				
				prevCenterx = centerx;
				prevCentery = centery;
				taille = 0;
				centerx = 0
				centery = 0;
				/* version basique */
				for (i = 0; i < img.width; i++)
				{
					for (j = 0; j < img.height; j++)
					{
						var RGB:int = img.getPixel(i, j);
						RGB = RGB + 16777216;
						var R:int = getR(RGB);
						var G:int = getG(RGB);
						var B:int = getB(RGB);
						if (R_min <= R && R <= R_max && G_min <= G && G <= G_max && B_min <= B && B <= B_max)
						{
							taille++;
							centerx += i;
							centery += j;
							img.setPixel(i,j,255*256*256);
							if (x == -1)
							{
								x = i;
								y = j;
								xx = i;
								yy = j;
							}
							else
							{
								if (i < x)
									x = i;
								if (i> xx)
									xx = i;
								if (j < y)
									y = j;
								if (j > yy)
									yy = j;
							}
						}
					}
				}
				centerx /= taille;
				centery /= taille;
				//drawRectangle(img, x, y, xx, yy, color);
			}
			private function searchColorAndBinaries(img:BitmapData, R_min:int, R_max:int, G_min:int, G_max:int, B_min:int, B_max:int, color:int) : void
			{
				var x:int = -1;
				var y:int = -1;
				var xx:int = -1;
				var yy:int = -1;
				var i:int;
				var j:int;
				/* version basique */
				for (i = 0; i < img.width; i++)
				{
					for (j = 0; j < img.height; j++)
					{
						var RGB:int = img.getPixel(i, j);
						RGB = RGB + 16777216;
						var R:int = getR(RGB);
						var G:int = getG(RGB);
						var B:int = getB(RGB);
						if (R_min <= R && R <= R_max && G_min <= G && G <= G_max && B_min <= B && B <= B_max)
						{
							img.setPixel(i,j,255*256*256 + 255*256 + 255);
							if (x == -1)
							{
								x = i;
								y = j;
								xx = i;
								yy = j;
							}
							else
							{
								if (i < x)
									x = i;
								if (i> xx)
									xx = i;
								if (j < y)
									y = j;
								if (j > yy)
									yy = j;
							}
						}
						else
						{
							img.setPixel(i,j,0);
						}
					}
				}
				
				drawRectangle(img, x, y, xx, yy, color);// 0 -> noir
			}

		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- Placer ici les éléments non visuels (services et objets de valeur, par exemple). -->
	</fx:Declarations>
	<s:VGroup>
		<s:HGroup>
			<s:VGroup width="100%" height="100%">
				<s:Label text="RED"/>
				<s:HSlider id="r_min" minimum="0" maximum="256" liveDragging="true" value="0"/>
				<s:HSlider id="r_max" minimum="0" maximum="256" liveDragging="true" value="58"/>
			</s:VGroup>
			<s:VGroup width="100%" height="100%">
				<s:Label text="GREEN"/>
				<s:HSlider id="g_min" minimum="0" maximum="256" liveDragging="true" value="52"/>
				<s:HSlider id="g_max" minimum="0" maximum="256" liveDragging="true" value="164"/>
			</s:VGroup>
			<s:VGroup width="100%" height="100%">
				<s:Label text="BLUE"/>
				<s:HSlider id="b_min" minimum="0" maximum="256" liveDragging="true" value="150"/>
 				<s:HSlider id="b_max" minimum="0" maximum="256" liveDragging="true" value="256"/>
			</s:VGroup>
		</s:HGroup>
		<s:HGroup width="100%">
			<s:Panel title="Votre webcam">
				<mx:VideoDisplay
					id="videoCamera"
					creationComplete="loadCamera();"
					width="{w}"
					height="{h}"/>
			</s:Panel>
			<s:VGroup width="100%" height="100%">
				<s:Label text="Profondeur: {taille}"/>
				<s:Label text="Ref : {tailleRef}"/>
				<s:Label text="Prev X: {prevCenterx}"/>
				<s:Label text="Prev Y: {prevCentery}"/>
				<s:Button
					id="buttonBegin"
					label="Commencer"
					click="clickButton();"
					/>
				<s:Button
					id="buttonErase"
					label="Erase"
					click="eraseScreen();"
					/>
			</s:VGroup>
		</s:HGroup>
		<s:HGroup width="100%">
			<s:Panel title="Detection de la couleur">
				<mx:UIComponent
					id="component"
					width="{w}"
					height="{h}"/>
			</s:Panel>
			<s:Panel title="Detection des mouvements">
				<mx:UIComponent
					id="componentMoved"
					width="{w}"
					height="{h}"/>
			</s:Panel>
		</s:HGroup>
	</s:VGroup>
		
</s:Application>
